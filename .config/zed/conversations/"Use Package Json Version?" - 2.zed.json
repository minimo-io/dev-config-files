{"id":"e1ce7481-a26b-4190-a199-276c48ebb926","zed":"context","version":"0.4.0","text":"\n\n\n\n```ts viiv-gateway-api/src/app.module.ts:1-55\n// Excerpt from: \n/**\n * @file app.module.ts\n * @description Main application module that imports other modules, defines global configuration,\n * registers Prometheus metrics middleware, and sets up a simple root endpoint to display API version.\n */\nimport { Module, MiddlewareConsumer, Controller, Get } from '@nestjs/common';\n\n// import { DatabaseModule } from './database/database.module';\nimport { ConfigModule, ConfigService } from '@nestjs/config';\n// import { CountriesModule } from './countries/countries.module';\n\nimport { PrometheusModule } from '@willsoto/nestjs-prometheus';\nimport { MetricsMiddleware } from './metrics.middleware';\n// import { PayinController } from './payin/payin.controller';\nimport { PayinModule } from './payin/payin.module';\n\n/**\n *   Inline AppController is defined inline within the AppModule to provide a simple endpoint at the root URL (/).\n *   It retrieves and exposes the current API version configured in the environment or configuration file.\n */\n@Controller()\nclass AppController {\n  constructor(private configService: ConfigService) {}\n\n  @Get()\n  getHello(): string {\n    return `Hello! API version: ${this.configService.get('app.version')}`;\n  }\n}\n\n/**\n * Main app module\n */\n@Module({\n  imports: [\n    ConfigModule.forRoot({ isGlobal: true }),\n    PrometheusModule.register({\n      path: '/metrics', // Prometheus will scrape metrics from this endpoint\n      defaultMetrics: {\n        enabled: false,\n      },\n    }),\n    PayinModule,\n    // DatabaseModule,\n    // CountriesModule,\n  ],\n  controllers: [AppController],\n  providers: [],\n})\nexport class AppModule {\n  configure(consumer: MiddlewareConsumer) {\n    consumer.apply(MetricsMiddleware).forRoutes('*');\n  }\n}\n\n```\nCouldn't i get the app version from my package.json?\nYes, you can absolutely retrieve the API version from your `package.json` file instead of using a configuration service. Here's how you can modify your `AppController` to achieve this:\n\n```typescript\nimport { Controller, Get } from '@nestjs/common';\nimport * as packageJson from '../package.json';\n\n@Controller()\nclass AppController {\n  @Get()\n  getHello(): string {\n    return `Hello! API version: ${packageJson.version}`;\n  }\n}\n```\n\nIn this updated version, we're importing the `package.json` file at the top using a require statement with path relative to the module. Then, we're accessing the `version` property from that imported object in the `getHello()` method.\n\nWith this approach, you don't need to manage the API version in your configuration anymore, and it will always match the one defined in your `package.json`.\nI got \"ts: Cannot find module '../package.json'. Consider using '--resolveJsonModule' to import module with '.json' extension.\"\nThe error you're encountering is because TypeScript's default resolution strategy doesn't include JSON files. To resolve this issue, you can use the `--resolveJsonModule` flag in your `tsconfig.json` file or add a `triple-slash reference` (also known as an `import map`) at the top of your module.\n\nHere are two ways to solve this problem:\n\n1. **Update tsconfig.json:**\n\nAdd `\"resolveJsonModule\": true` to your `compilerOptions`:\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2017\",\n    \"module\": \"CommonJS\",\n    \"outDir\": \"./dist\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"resolveJsonModule\": true\n  },\n  ...\n}\n```\n\nAfter updating the config file, restart your TypeScript compilation process (e.g., by rebuilding your project).\n\n2. **Use triple-slash reference:**\n\nAdd a `/// <reference path=\"../package.json\" />` comment at the top of your module:\n\n```typescript\n/// <reference path=\"../package.json\" />\n\nimport { Controller, Get } from '@nestjs/common';\n\n@Controller()\nclass AppController {\n  @Get()\n  getHello(): string {\n    return `Hello! API version: ${(<any>packageJson).version}`;\n  }\n}\n```\n\nWith this approach, you don't need to modify your `tsconfig.json` file. However, you'll need to cast the imported `packageJson` object to any type (`<any>`) before accessing its properties.\n\nEither of these solutions should resolve the issue and allow you to import the `package.json` file in your TypeScript code.\nNow i got this: eslint: Do not use a triple slash reference for ../package.json, use `import` style instead\n\nIf you're getting an ESLint error because you've used a triple-slash reference (///) for importing `../package.json`, you can update the import statement to use a regular `import` declaration with the `require()` function as follows:\n\n```typescript\nimport * as packageJson from '../package.json';\nimport { Controller, Get } from '@nestjs/common';\n\n@Controller()\nclass AppController {\n  @Get()\n  getHello(): string {\n    return `Hello! API version: ${packageJson.version}`;\n  }\n}\n```\n\nThis approach should satisfy both TypeScript's resolution strategy and ESLint's rules. Make sure that your `tsconfig.json` file has the `\"resolveJsonModule\": true` option set or the import will fail at compile time.\n\nHere's an updated example of the `tsconfig.json` file:\n\n```json\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2017\",\n    \"module\": \"CommonJS\",\n    \"outDir\": \"./dist\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"resolveJsonModule\": true,\n    \"forceConsistentCasingInFileNames\": true\n  },\n  ...\n}\n```\n\nWith this setup, you should no longer encounter the ESLint error when importing `../package.json` using the regular `import` statement.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":95}}},{"id":{"replica_id":0,"value":14},"start":1825,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":96}}},{"id":{"replica_id":0,"value":15},"start":2653,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":97}}},{"id":{"replica_id":0,"value":55},"start":2781,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":98}}},{"id":{"replica_id":0,"value":56},"start":4215,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":99}}},{"id":{"replica_id":0,"value":78},"start":4324,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":100}}},{"id":{"replica_id":0,"value":79},"start":5467,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":101}}}],"summary":"\"Use Package Json Version?\"","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null}]}