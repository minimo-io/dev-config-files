{"id":"19b49838-81fb-46fb-86f1-d760ae8785ee","zed":"context","version":"0.4.0","text":"\n\n\n\n```ts viiv-gateway-api/src/app.module.ts:1-33\n// Excerpt from: \nimport { Module, MiddlewareConsumer } from '@nestjs/common';\n\n// import { DatabaseModule } from './database/database.module';\nimport { ConfigModule } from '@nestjs/config';\n// import { CountriesModule } from './countries/countries.module';\n\nimport { PrometheusModule } from '@willsoto/nestjs-prometheus';\nimport { MetricsMiddleware } from './metrics.middleware';\n// import { PayinController } from './payin/payin.controller';\nimport { PayinModule } from './payin/payin.module';\n\n@Module({\n  imports: [\n    ConfigModule.forRoot({ isGlobal: true }),\n    PrometheusModule.register({\n      path: '/metrics', // Prometheus will scrape metrics from this endpoint\n      defaultMetrics: {\n        enabled: false,\n      },\n    }),\n    PayinModule,\n    // DatabaseModule,\n    // CountriesModule,\n  ],\n  // controllers: [PayinController],\n  providers: [],\n})\nexport class AppModule {\n  configure(consumer: MiddlewareConsumer) {\n    consumer.apply(MetricsMiddleware).forRoutes('*');\n  }\n}\n\n```\nHere i want to add the simplest endpoint in the base url (/) that exposes the current api version\nTo create a simple endpoint in the base URL (`/`) that exposes the current API version, you can follow these steps:\n\n1. Create an `app.controller.ts` file with the following content:\n\n```typescript\nimport { Controller, Get } from '@nestjs/common';\nimport { ConfigService } from '@nestjs/config';\n\n@Controller()\nexport class AppController {\n  constructor(private configService: ConfigService) {}\n\n  @Get()\n  getHello(): string {\n    return `Hello! API version: ${this.configService.get('app.version')}`;\n  }\n}\n```\n\n2. Import the newly created `AppController` in your `app.module.ts`:\n\n```typescript\nimport { Module, MiddlewareConsumer } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport { PrometheusModule } from '@willsoto/nestjs-prometheus';\nimport { MetricsMiddleware } from './metrics.middleware';\nimport { PayinModule } from './payin/payin.module';\nimport { AppController } from './app.controller'; // Import the new controller\n\n@Module({\n  imports: [\n    ConfigModule.forRoot({ isGlobal: true }),\n    PrometheusModule.register({\n      path: '/metrics',\n      defaultMetrics: {\n        enabled: false,\n      },\n    }),\n    PayinModule,\n  ],\n  controllers: [AppController], // Add the new controller to the module\n  providers: [],\n})\nexport class AppModule {\n  configure(consumer: MiddlewareConsumer) {\n    consumer.apply(MetricsMiddleware).forRoutes('*');\n  }\n}\n```\n\n3. Make sure you have defined an `app.version` property in your environment file or configuration:\n\nFor `.env` file:\n\n```\nAPP_VERSION=1.0.0\n```\n\nFor `config.default.ts`:\n\n```typescript\nexport default {\n  app: {\n    version: '1.0.0',\n  },\n};\n```\n\nNow, if you navigate to the base URL (`/`) of your application, it will display the message \"Hello! API version: <version>\", where `<version>` is the current API version defined in your configuration.\n\nExample response:\n\n```\nHello! API version: 1.0.0\n```\nCouldn't i just use an inline controller in the app.module.ts?\nYes, you can also define the endpoint directly within the `AppModule` using an inline controller instead of creating a separate `app.controller.ts` file. Here's how you can do that:\n\n1. Update your `app.module.ts` with the following changes:\n\n```typescript\nimport { Module, MiddlewareConsumer, Controller, Get } from '@nestjs/common';\nimport { ConfigModule } from '@nestjs/config';\nimport { PrometheusModule } from '@willsoto/nestjs-prometheus';\nimport { MetricsMiddleware } from './metrics.middleware';\nimport { PayinModule } from './payin/payin.module';\n\n@Controller()\nclass AppController {\n  constructor(private configService: ConfigService) {}\n\n  @Get()\n  getHello(): string {\n    return `Hello! API version: ${this.configService.get('app.version')}`;\n  }\n}\n\n@Module({\n  imports: [\n    ConfigModule.forRoot({ isGlobal: true }),\n    PrometheusModule.register({\n      path: '/metrics',\n      defaultMetrics: {\n        enabled: false,\n      },\n    }),\n    PayinModule,\n  ],\n  controllers: [AppController], // Remove the import statement for AppController\n  providers: [],\n})\nexport class AppModule {\n  configure(consumer: MiddlewareConsumer) {\n    consumer.apply(MetricsMiddleware).forRoutes('*');\n  }\n}\n```\n\n2. Since we're now using an inline controller, remove the `import { AppController } from './app.controller';` line at the top of the module.\n\nThe rest of the code remains the same as before. Now you should still have the endpoint at the base URL (`/`) that exposes the current API version defined in your configuration.\n\nThis approach keeps everything within a single file, but it might make the `app.module.ts` slightly harder to read and maintain for larger applications with many endpoints or controllers.\nWhere is `ConfigService` imported?\nApologies for missing that detail. You'll need to import `ConfigService` from `@nestjs/config` package at the top of your `app.module.ts`:\n\n```typescript\nimport { Module, MiddlewareConsumer, Controller, Get } from '@nestjs/common';\nimport { ConfigModule, ConfigService } from '@nestjs/config'; // Import ConfigService here\n// ... other imports\n```\n\nAnd then you can use it in your inline controller like this:\n\n```typescript\n@Controller()\nclass AppController {\n  constructor(private configService: ConfigService) {} // Use ConfigService\n\n  @Get()\n  getHello(): string {\n    return `Hello! API version: ${this.configService.get('app.version')}`;\n  }\n}\n```\n\nWith this change, the `ConfigService` is now available within your inline controller to retrieve the API version from the configuration.\nPlease comment this inline controller, like i did in pix.service.exception.ts:\n/**\n * @file pix.service.exception.ts\n * @description This file defines a custom exception class, PixServiceException, used for handling errors\n * specific to the PIX service. By extending NestJS's HttpException, this class ensures that errors\n * thrown during PIX service operations are caught and processed consistently by the global exception filter.\n *\n * Usage:\n *   throw new PixServiceException('Invalid PIX request', 400);\n */\n\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":308}}},{"id":{"replica_id":0,"value":39},"start":1148,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":309}}},{"id":{"replica_id":0,"value":40},"start":3047,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":310}}},{"id":{"replica_id":0,"value":82},"start":3110,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":311}}},{"id":{"replica_id":0,"value":83},"start":4829,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":312}}},{"id":{"replica_id":0,"value":155},"start":4864,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":313}}},{"id":{"replica_id":0,"value":156},"start":5657,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":314}}},{"id":{"replica_id":0,"value":277},"start":5736,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":315}}},{"id":{"replica_id":0,"value":302},"start":6171,"metadata":{"role":"assistant","status":"Pending","timestamp":{"replica_id":0,"value":316}}},{"id":{"replica_id":0,"value":303},"start":6172,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":317}}}],"summary":"AddAPIVersionEndpoint","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null}]}