{"id":"e8671914-816f-43a5-a85d-e6456cad1f86","zed":"context","version":"0.4.0","text":"\n\n\n\n```rs ~/.cargo/registry/src/index.crates.io-6f17d22bba15001f/actix-web-4.9.0/src/lib.rs:1-150\n// Excerpt from: \n//! Actix Web is a powerful, pragmatic, and extremely fast web framework for Rust.\n//!\n//! # Examples\n//! ```no_run\n//! use actix_web::{get, web, App, HttpServer, Responder};\n//!\n//! #[get(\"/hello/{name}\")]\n//! async fn greet(name: web::Path<String>) -> impl Responder {\n//!     format!(\"Hello {}!\", name)\n//! }\n//!\n//! #[actix_web::main] // or #[tokio::main]\n//! async fn main() -> std::io::Result<()> {\n//!     HttpServer::new(|| {\n//!         App::new().service(greet)\n//!     })\n//!     .bind((\"127.0.0.1\", 8080))?\n//!     .run()\n//!     .await\n//! }\n//! ```\n//!\n//! # Documentation & Community Resources\n//! In addition to this API documentation, several other resources are available:\n//!\n//! * [Website & User Guide](https://actix.rs/)\n//! * [Examples Repository](https://github.com/actix/examples)\n//! * [Community Chat on Discord](https://discord.gg/NWpN5mmg3x)\n//!\n//! To get started navigating the API docs, you may consider looking at the following pages first:\n//!\n//! * [`App`]: This struct represents an Actix Web application and is used to\n//!   configure routes and other common application settings.\n//!\n//! * [`HttpServer`]: This struct represents an HTTP server instance and is\n//!   used to instantiate and configure servers.\n//!\n//! * [`web`]: This module provides essential types for route registration as well as\n//!   common utilities for request handlers.\n//!\n//! * [`HttpRequest`] and [`HttpResponse`]: These\n//!   structs represent HTTP requests and responses and expose methods for creating, inspecting,\n//!   and otherwise utilizing them.\n//!\n//! # Features\n//! - Supports HTTP/1.x and HTTP/2\n//! - Streaming and pipelining\n//! - Powerful [request routing](https://actix.rs/docs/url-dispatch/) with optional macros\n//! - Full [Tokio](https://tokio.rs) compatibility\n//! - Keep-alive and slow requests handling\n//! - Client/server [WebSockets](https://actix.rs/docs/websockets/) support\n//! - Transparent content compression/decompression (br, gzip, deflate, zstd)\n//! - Multipart streams\n//! - Static assets\n//! - SSL support using OpenSSL or Rustls\n//! - Middlewares ([Logger, Session, CORS, etc](middleware))\n//! - Integrates with the [`awc` HTTP client](https://docs.rs/awc/)\n//! - Runs on stable Rust 1.54+\n//!\n//! # Crate Features\n//! - `cookies` - cookies support (enabled by default)\n//! - `macros` - routing and runtime macros (enabled by default)\n//! - `compress-brotli` - brotli content encoding compression support (enabled by default)\n//! - `compress-gzip` - gzip and deflate content encoding compression support (enabled by default)\n//! - `compress-zstd` - zstd content encoding compression support (enabled by default)\n//! - `openssl` - HTTPS support via `openssl` crate, supports `HTTP/2`\n//! - `rustls` - HTTPS support via `rustls` 0.20 crate, supports `HTTP/2`\n//! - `rustls-0_21` - HTTPS support via `rustls` 0.21 crate, supports `HTTP/2`\n//! - `rustls-0_22` - HTTPS support via `rustls` 0.22 crate, supports `HTTP/2`\n//! - `rustls-0_23` - HTTPS support via `rustls` 0.23 crate, supports `HTTP/2`\n//! - `secure-cookies` - secure cookies support\n\n#![doc(html_logo_url = \"https://actix.rs/img/logo.png\")]\n#![doc(html_favicon_url = \"https://actix.rs/favicon.ico\")]\n#![cfg_attr(docsrs, feature(doc_auto_cfg))]\n\npub use actix_http::{body, HttpMessage};\n#[cfg(feature = \"cookies\")]\n#[doc(inline)]\npub use cookie;\n\nmod app;\nmod app_service;\nmod config;\nmod data;\npub mod dev;\npub mod error;\nmod extract;\npub mod guard;\nmod handler;\nmod helpers;\npub mod http;\nmod info;\npub mod middleware;\nmod redirect;\nmod request;\nmod request_data;\nmod resource;\nmod response;\nmod rmap;\nmod route;\npub mod rt;\nmod scope;\nmod server;\nmod service;\npub mod test;\nmod thin_data;\npub(crate) mod types;\npub mod web;\n\n#[doc(inline)]\npub use crate::error::Result;\npub use crate::{\n    app::App,\n    error::{Error, ResponseError},\n    extract::FromRequest,\n    handler::Handler,\n    request::HttpRequest,\n    resource::Resource,\n    response::{CustomizeResponder, HttpResponse, HttpResponseBuilder, Responder},\n    route::Route,\n    scope::Scope,\n    server::HttpServer,\n    types::Either,\n};\n\nmacro_rules! codegen_reexport {\n    ($name:ident) => {\n        #[cfg(feature = \"macros\")]\n        pub use actix_web_codegen::$name;\n    };\n}\n\ncodegen_reexport!(main);\ncodegen_reexport!(test);\ncodegen_reexport!(route);\ncodegen_reexport!(routes);\ncodegen_reexport!(head);\ncodegen_reexport!(get);\ncodegen_reexport!(post);\ncodegen_reexport!(patch);\ncodegen_reexport!(put);\ncodegen_reexport!(delete);\ncodegen_reexport!(trace);\ncodegen_reexport!(connect);\ncodegen_reexport!(options);\ncodegen_reexport!(scope);\n\npub(crate) type BoxError = Box<dyn std::error::Error>;\n\n```\nExplain this module in a bullet list, and give me a usage example\nHere is a summary of the Actix Web module in bullet points:\n\n*   **Overview**: Actix Web is a powerful, pragmatic, and extremely fast web framework for Rust.\n*   **Features**:\n    *   Supports HTTP/1.x and HTTP/2\n    *   Streaming and pipelining\n    *   Powerful request routing with optional macros\n    *   Full Tokio compatibility\n    *   Keep-alive and slow requests handling\n    *   Client/server WebSockets support\n    *   Transparent content compression/decompression (br, gzip, deflate, zstd)\n    *   Multipart streams\n    *   Static assets\n    *   SSL support using OpenSSL or Rustls\n    *   Middlewares (Logger, Session, CORS, etc.)\n    *   Integrates with the awc HTTP client\n    *   Runs on stable Rust 1.54+\n*   **Crate Features**: Various features can be enabled or disabled using the `#[cfg(feature = \"feature_name\")]` attribute.\n*   **Error Handling**: Uses a custom error type `Box<dyn std::error::Error>` to handle errors.\n\nHere is an example of creating a simple web server that responds with a hello message:\n\n```rust\nuse actix_web::{web, App, HttpServer};\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    HttpServer::new(|| {\n        App::new().service(web::resource(\"/hello\").to(|| async { \"Hello World!\" }))\n    })\n    .bind(\"127.0.0.1:8080\")?\n    .run()\n    .await\n}\n```\n\nThis code creates a new `HttpServer` instance, defines a single route at `/hello` that returns the string \"Hello World!\", and binds it to port 8080. When you run this program and access `http://127.0.0.1:8080/hello`, you should see the message \"Hello World!\".\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":14}}},{"id":{"replica_id":0,"value":8},"start":4858,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":15}}},{"id":{"replica_id":0,"value":9},"start":6429,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":16}}}],"summary":"**actix web framework**","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null}]}